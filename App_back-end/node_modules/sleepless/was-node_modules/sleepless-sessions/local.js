// Copyright 2023  Sleepless Softawre Inc. All Rights Reserved


delete require.cache[ module.filename ];	// reload every time.

const DS = require( "ds" );

// Return ASCII sha1 for a string
function sha1(s) {
    var h = require( "crypto" ).createHash("sha1");
    h.update(s);
    return h.digest("hex");
};

// Return a Unix timestamp for current time, or for a Date object if provided
function time() {
    return Math.round( Date.now() / 1000 );
}

const { log, warn, error } = console;


//  -   -   -   -   -   -   -   -   -   -   -   -   -   -   


const SESSION_TTL = 60 * 60 * 24;
const RESET_CODE_TTL = 60 * 60 * 4;

const user_db = new DS( "users.json" );
const active_sessions = new DS( "sessions.json" );


//  -   -   -   -   -   -   -   -   -   -   -   -   -   -   

// Create and return a random, 40 char sha1 hash
function make_hash40() {
    return sha1( "" + ( time() + Math.random() ) );
}


// Create and return a new session object for a username
function make_session( username ) {
    return { sid: make_hash40(), expires: time() + SESSION_TTL, username, }
}


// Create and return a new user object
function make_user( email, username, password ) {
    return { email, username, password, created: time(), }
}


//  -   -   -   -   -   -   -   -   -   -   -   -   -   -   

// Get session object for an sid or null if sid is invalid
function get_session( sid, done, fail ) {
    // XXX constrain/validate
    let session = active_sessions[ sid ] || null;
    if( session && time() <= session.expires ) {
        session.user = user_db[ session.username ];
    }
    done( { session } );
}


// Get user object for given a username
function get_user( user_or_email, done, fail ) {
    // XXX constrain/validate
    let user = null;
    if( user_or_email.is_email() ) {
        // looks like an email addr
        const email = user_or_email;
        // search for user with that email
        for( const u of Object.values( user_db ) ) {
            if( u.email === email ) {
                user = u;
                break;
            }
        }
    } else {
        user = user_db[ user_or_email ] || null;
    }
    done( { user } );
}


function get_user_from_reset_code( reset_code, done, fail ) {
    log("     gufrc "+reset_code);
    for( const u of Object.values( user_db ) ) {
        if( ! u.reset ) 
            continue;
        log("     ... "+u.reset.code);
        if( u.reset.code !== reset_code )
            continue;
        if( time() >= u.reset.expires ) {
            log("     expired "+reset_code);
            continue;
        }
        log("     found "+reset_code);
        done( u );
        return;
    }
    done( null );
}


// Reset the timeout for an active session
function freshen_session( sid, done, fail ) {
    const session = active_sessions[ sid ];
    if( ! session || time() >= session.expires ) {
        // bad sid or session expired
        delete active_sessions[ sid ];
        active_sessions.save();
        done( { error: "Invalid session ID" } );
        return;
    }
    // session still valid - freshen it
    session.expires = time() + SESSION_TTL;
    active_sessions.save();
    session.user = user_db[ session.username ];
    done( { session } );    // return the freshened session
}


// Clear/delete a session
function end_session( sid, done, fail ) {
    const session = active_sessions[ sid ];
    if( session ) {
        delete active_sessions[ sid ];
        active_sessions.save();
    }
    done( {} );
}


// Authenticate/login a new user account
// Returns a session object if successful
function authenticate( user_or_email, password, done, fail ) {

    get_user( user_or_email, ( { user } ) => {

        if( ! user ) {
            warn( "No such user: " + user_or_email );
            done( { error: "Denied" } );
            return;
        }

        if( user.password != password ) {
            warn( "Wrong password: " + user.username );
            done( { error: "Denied" } );
            return;
        }

        // sanitize user object
        const { username, email, created, } = user; // extract fields I want
        user = { username, email, created, };       // build back into object

        const session = make_session( username );
        active_sessions[ session.sid ] = session;
        active_sessions.save();

        const s2 = {
            sid: session.sid,
            expires: session.expires,
            user,
        }

        done( { session: s2 } );

    }, fail );

}


// Register a new user account
function register( email, username, password, done, fail ) {
    if( ! ( "" + username ).match( /^[-_A-Za-z0-9]+$/ ) ) {
        done( { error: "Username contains disallowed characters", username } );
        return;
    }
    let user = user_db[ username ];
    if( user ) {
        done( { error: "Username is already registered", username } );
        return;
    }
    if( ! ( "" + email ).is_email() ) {
        done( { error: "Email address is invalid", email } );
        return;
    }
    if( ( "" + password ).length < 8 ) {
        done( { error: "Password is too short", } );
        return;
    }
    user = make_user( email, username, password );
    user_db[ username ] = user;
    user_db.save();
    done( { username } );
}


// Delete a user account
function unregister( username, password, done, fail ) {
    const user = user_db[ username ];
    if( ! user ) {
        done( { error: "Denied" } );
        return;
    }
    if( user.password != password ) {
        done( { error: "Denied" } );
    }
    delete user_db[ username ];
    user_db.save();
    done( { username } );   // success
}


// Generates a password reset code for a user and returns it
// The code is only valid for limited time and reset_password() (below)
// must be called before it expires.
function reset_password_code( username, done, fail ) {
    const user = user_db[ username ];
    if( ! user ) {
        done( { error: "No such user" } );
        return;
    }
    let reset = user.reset;
    if( typeof reset !== "object" ) {
        reset = user.reset = {};
    }
    reset.code = make_hash40();
    reset.expires = time() + RESET_CODE_TTL;
    user_db.save();
    done( { code: reset.code, } );
}


// Set a new password for a user.
// The reset_code must still be valid (see above)
// NOTE: There's not username provided here, we have to look it up
function reset_password( reset_code, new_password, done, fail ) {
    get_user_from_reset_code( reset_code, user => {
        if( ! user ) {
            done( { error: "Denied" } );
            return;
        }
        // found user with the reset code and it hasn't expired
        delete user.reset;              // clear the reset code
        user.password = new_password;   // set the new pw
        user_db.save();
        done( {} ); 
    }, fail )
}

//  -   -   -   -   -   -   -   -   -   -   -   -   -   -   

module.exports = {
    register,
    unregister,
    authenticate,
    get_user,
    get_session,
    freshen_session,
    end_session,
    reset_password_code,
    reset_password,
};

